**Part 1: Introduction to Software Engineering**

**1. Explain what software engineering is and discuss its importance in the technology industry.**

Software engineering is a systematic and disciplined approach to designing, developing, testing, deploying, and maintaining software applications.
 
**Importance in the technology industry**

**Guarantees Software Quality** – Software engineering principles enable the delivery of reliable, high-performing, and bug-free software applications. 

**Allows for Scalability** – Software that is properly architected can scale with users and system complexity.

**Encourages Innovation** – Enables businesses to create next-generation technologies such as AI, blockchain, and cloud computing.

**Enhances Security** – Strong engineering practices safeguard against breaches and secure sensitive data.

**Boosts Economic Development** – The software industry adds considerably to world economies through employment opportunities and technological developments.

**2. Identify and describe at least three key milestones in the evolution of software engineering**.  

**Mastering the Process**

Software engineering was born as a result of the first software crisis in this period. Enhancing quality and productivity while lowering development risk was the goal. It seemed that software development approaches defined and tracked software development. The structured modelling technique that makes execution automation possible was one of this stage's major contributions. 

**Mastering complexity**

With mass personal computer use, software becomes more complex. Object-Oriented (OO) methodologies like those in Smalltalk and C++ transformed software development. It improved development efficiency, as OO programming enabled improved software modularity, reusability, and maintainability. GUIs and visual programming made software more approachable. There were CASE (Computer-Aided Software Engineering) tools to support the structured and OO development.

**3. List and briefly explain the phases of the Software Development Life Cycle.**

**Planning**

1.It defines the project scope, objective and feasibility.
	
2.Estimates cost, resources, and timeline.
	
3.It identifies possible risks and mitigation techniques.

**Requirements Analysis**

1.It collects and documents functional as well as nonfunctional requirements.
	
2.Raises awareness of the needs of stakeholders.
	
3.It creates Software Requirement Specification (SRS) documents.

**Design**

1.It defines system architecture, user interface and database structures.
	
2.Creates detailed blueprints for development.
	
3.It consists of High-Level Design (HLD) and Low Level Design (LLD).

**Implementation (Coding)**

1.Converts design docs and other ideas into the actual software with the use of the programming language.
	
2.Complies with the coding standards and best practices.
	
3.Integrates different system components.

**Testing**

1.Fixes defects before the deployment.
	
2.It has unit testing, integration testing, system testing and user acceptance testing (UAT).
	
3.It ensures that software is equipped with requirements and works as expected.

**Deployment**

1.Releases the software to the production environment.
	
2.It can be done in phases, such as beta testing and full rollout.
	
3.Ensures minimal disruptions during implementation.

**Maintenance & Support**

1.It offers bug fixes and performance improvements as well as updates.
	
2.It ensures that software will always be secure to meet the changing needs.
	
3.Addresses user feedback for enhancements.

**Mastering machine**

The internet and web application boom transformed software engineering. Decentralised computing and distributed architectures hit the mainstream. This led to the emergence of further disciplines such as web engineering that concentrated on the construction of scalable and efficient web applications. Introduction of software quality standards like Capability Maturity Model (CMM) and Capability Maturity Model Integration (CMMI) in order to control the process and product.

**4. Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.**

The Waterfall and Agile methodologies are two distinct approaches to software development, each with its own strengths and use cases. Waterfall follows a sequential and linear approach, meaning that development progresses through fixed phases such as requirements gathering, design, implementation, testing, deployment, and maintenance. Once a phase is completed, revisiting it is difficult, making Waterfall rigid and less adaptable to changing requirements. In contrast, Agile takes an iterative and flexible approach, breaking the development process into smaller sprints or cycles. This allows for continuous improvements based on ongoing feedback.

One of the key differences between the two is customer involvement. Waterfall requires minimal interaction with the customer, as feedback is typically collected only after the final product is delivered. Agile, on the other hand, emphasizes continuous collaboration, ensuring that customers provide input throughout the development process. This results in faster delivery of working software in small increments rather than waiting until the end.

Another major distinction lies in risk management. Since Waterfall postpones testing until later phases, any critical issues may only surface late in development, increasing risks. Agile mitigates this by incorporating early and frequent testing, reducing the chances of major failures. Additionally, documentation plays a different role in each methodology—Waterfall requires heavy documentation upfront, ensuring detailed planning, while Agile focuses more on lightweight documentation, prioritizing working software over extensive paperwork.

Waterfall is best suited for projects with well-defined, stable requirements, such as government systems or large-scale infrastructure projects where changes are minimal. Agile, on the other hand, is ideal for dynamic projects where requirements may evolve, such as mobile app development or startups creating innovative products. Understanding the strengths and limitations of each methodology helps teams choose the right approach based on their project needs.

**5. Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.**

**Software Developer**

A software developer designs, codes, and maintains a software application.

**Key Responsibilities:**

1.Develop clean, efficient and maintainable code.
	
2.Develop software based on design and requirements.
	
3.Troubleshooting and debugging software problems.
	
4.Working alongside other developers, designers, and stakeholders
	
5.Staying updated with newer programming languages and frameworks

**QA (Quality Assurance) Engineer**

A QA engineer is responsible for ensuring software quality and that it works as intended.

**Key Responsibilities:**

1.Writing and performing test cases (both manual and automated).
	
2.Bug Identification and Reporting Best Practices
	
3.Verifying software correctness about functional and non-functional requirements.
	
4.Getting defects fixed with developers.
	
5.Regression, usability and security testing.

**Project Manager (PM)**
	
The project manager is responsible for managing the entire software development process, ensuring that projects are completed on time and within budget, and aligning the project with business goals.

**Key Responsibilities:**

1.Defining project scope, timelines, and milestones.
	
2.Distribution of resources and the workload of the team
	
3.Interacting with stakeholders and making sure project requirements are fulfilled.
	
4.Work to find risks and how to mitigate them.
	
5.Diligently administering Agile, Scrum, and Waterfall practices whenever required to ensure the team follows the process.

**6. Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.**

**1. Integrated Development Environments (IDEs)**

An IDE (Integrated Development Environment) is a software application that offers the complete tools to write, debug, and test code in one interface.
**Importance of IDEs:**

**Increases Productivity** – Offers features such as code completion, syntax highlighting, and debugging tools.

**Minimises Mistakes** — Inbuilt debugging and error detection prevent coding errors.

**Improves Code Control** – It is compatible with various programming languages, frameworks, and libraries.

**It Checks and Simplifies Development**: You can edit, compile, and execute all in one environment.


**Examples of IDEs:**

Visual Studio Code, PyCharm, Eclipse


**2. Version Control Systems (VCS)**

A version control system (VCS) is a category of software tools that helps software teams manage changes to source code over time.

**Importance of VCS:**

**Enables Collaboration** – Several engineers can contribute to the same codebase without conflicts.

**Tracks Changes** – Keeps a record of edits and rolls back to previous versions.

**Supports Branching and Merging** — Developers can independently work on features and then merge them into the main project.

**Improves Code Protection** – Gives backup & prevents code loss.


**Examples of VCS:**

Git, GitHub, Subversion (SVN)

**7. What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.**

Managing complex codebases is one of the most common challenges that developers face, particularly as projects expand in terms of size and scale. Making a codebase grow wider might come to be difficult to maintain. To prevent it, engineers should use general best coding practices (modular programming, coding standards, version control systems (GIT) that allow tracking changes, brainstorming, and teamwork on a common task).
	
Deadlines are another major challenge: delivering projects on time without compromising quality. Tight deadlines can cause development to be rushed, leading to more bugs and debt. Agile methodologies like Scrum or Kanban could aid in dividing projects into manageable bits, enabling steady feedback and incremental enhancements. Focusing on task automation will also increase efficiency, like testing and deployment.

Another big challenge is debugging and troubleshooting complex problems. Hidden bugs, performance bottlenecks, or unexpected user interactions make software often behave unpredictably. A few examples of tools engineers can use include debugging tools, logging mechanisms, and automated testing frameworks to catch errors relatively early on. Pair programming and code reviews are also effective practices that offer new insights into solving problems as well as improving the quality of the code.
	
The software industry is constantly moving towards advancement with a new programming language, framework, or best practise that scrolls in, and keeping up with these changes is essential but challenging. Engineers should attend technology-focused workshops, take online courses, and read industry blogs in order to learn continuously. Working with a group that fosters a knowledge-sharing environment also contributes to engineers keeping abreast of the latest trends.

**8. Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.**

**Unit Testing**

Unit testing is a type of testing wherein individual components or functions of a software application are tested in isolation. Test cases are created by developers to ensure that each function, method, or module works as expected.

**Importance:**

1.Detects the bugs as early in the development phase, hence avoiding the cost involved in debugging.
	
2.Verifies that each component works correctly in isolation before being integrated.
	
3.It helps ensure the quality and stability of the code, especially when updating existing code.

**Integration Testing**

Integration testing assesses the interaction between different software modules when they are integrated together. It makes sure data gets routed correctly between components.

**Importance:**

1.Locates interface defects between modules.
	
2.Ensures smooth messaging between parts of the software.
	
3.Solves problems that arise when independent modules are combined.

**System Testing**

System testing checks the completed and integrated applications to ensure that they satisfy both functional and non-functional requirements. In other words, it tests the whole application.

**Importance:**

1.Checks that the software is working as designed in its full-sized version.
	
2.Map system-wide problems like performance bottlenecks or security weaknesses.
	
3.Verifies that the application is suitable for its environment and requirements, including hardware and software dependencies.

**Part 2: Introduction to AI and Prompt Engineering**

**Define prompt engineering and discuss its importance in interacting with AI models.**

Prompt engineering is the procedure for designing and enhancing input prompts to maximize output in response to the variety of AI models. It deals with constructing structured, precise and contextually appropriate queries to produce more useful, accurate and coherent outputs from an AI system like ChatGPT.

**Importance of Prompt Engineering in AI Interaction**

1.Structured prompts help steer the AI towards right and accurate answers.
	
2.It allows the users to quickly get the desired information with minimal trial and error.
	
3.Prompts can convey the complexity of the answer, or the writing style, or the intended readership.
	
4.Essential for creating AI applications like chatbots, virtual assistants, and content generators.
	
5.The use of thoughtfully crafted prompts helps reduce the risk of prompts allowing ambiguous or misleading outputs to slip through.

**Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.**

**Initial prompt**: "Tell me about technology."

**Improved Prompt:**

"Explain the impact of artificial intelligence on the healthcare industry, including its benefits and challenges."

**Why the Improved Prompt is More Effective:**

**More Specific** – The new prompt is better than the one it replaces, as it isn’t asking about "technology" in general but rather "artificial intelligence in healthcare."

**Clearly Defined Scope** – The AI will be directed to balance out the response with benefits and challenges.

**Concise and Precise** – This removes ambiguity because the AI can generate a tangible and structured response.



